# 컴퓨터 밑바닥의 비밀

## 언어부터 실행까지
- 인간의 추상적인 표현을 CPU가 이해할 수 있는 구체적인 구현으로 변환할 수 있는 방법이 프로그래밍
- Statement: 프로그램이 수행할 동작을 명령하는 최소 단위의 독립적인 코드 구문
- Syntax: 프로그래밍 언어에서 문장을 올바르게 구성하기 위한 규칙의 집합
- Tree: 프로그램의 구조를 계층적으로 표현하는 자료구조로, 컴파일러가 코드를 분석하고 처리하는데 사용
- Compiler
  * 소스 코드에서 토큰을 추출(Lexical Analysis, 어휘분석)
  * 구문 트리 생성(Parsing, 구문 분석)
  * 이상 확인(Semantic analysis, 의미 분석)
- Linker
  * 컴파일러가 생성한 코드를 모듈 단위로 묶어 실행 파일 생성
  * 모듈 간 참조 관계 해결
  * 메모리 주소 할당
  * 대상 파일 > 실행 파일 생성
  * 동적 라이브러리는 프로그램이 메모리에 적재될 때 링크 과정 수행, Loader가 동적 라이브러리를 로드하고 링크
    * Spring Boot에서 많은 Spring Dependency를 추가해도 괜찮은 것이 동적 라이브러리를 사용하기 때문인가?
      * 지연 로딩(Lazy Loading)
        * 실제로 필요한 시점에만 라이브러리가 메모리에 로드됩니다
        * 사용하지 않는 의존성은 메모리를 차지하지 않습니다
      * 공유 라이브러리
        * JVM 위에서 실행되는 여러 애플리케이션이 같은 라이브러리를 공유할 수 있습니다
        * 메모리 사용량이 중복되지 않습니다
      * 자동 구성(Auto-configuration)
        * Spring Boot는 실제로 사용되는 기능만 구성합니다
        * 클래스패스에 있더라도 사용하지 않는 기능은 초기화되지 않습니다
  * 단점은 종속된 라이브러리를 제공하지 않거나 버전이 호환되지 않을 경우 까다로운 것

## 프로그램의 실행
- Program
  * 메모리에서 명령어(instruction)를 가져온다(dispatch)
  * PC(Program Counter) Register에 명령어 주소를 저장
  * 주소를 1씩 증가 또는 함수나 분기를 만나면 동적으로 실행 순서 변경
  * Context를 저장하면서 Process를 빠르게 전환하는 것으로 멀티태스킹을 구현
  * Operating System의 등장
  * OS는 코드 재사용성의 정수
  * IPC(Inter-Process Communication)는 OverHead, 프로세스마다 주소 공간이 달라 복잡한 구현
  * 힙, 스택, 데이터, 코드 영역 외의 메모리 여유 공간에는 동적 라이브러리의 코드와 데이터가 적재 
  * Thread
    * main 함수는 특별한가? 프로그램이 시작될 때 CPU가 실행하는 첫 번째 함수일 뿐이다. 
    * PC 레지스터가 다른 함수를 가리키게 할 수 있으면 새로운 실행 흐름을 형성할 수 있다 > 스레드
    * Thread-per-request 는 스레드의 생성과 종료에 많은 리소스 사용 > Thread-pool
    * producer-consumer pattern
    * Thread는 코드 영역에 read-only, 데이터 영역, 힙 영역에 write
    * 스레드 안전 문제의 핵심은 어떤 것이 스레드 전용 리소스이고, 어떤 것이 공유 리소스인지 구분하는 데 있다
      * 공유 리소스에의 접근은 각종 잠금이나 세마포어 같은 장치를 이용해야 한다
      * 무상태 함수, 불변 객체, 읽기 전용, 동기화 시 상호 배제 등으로 스레드 안전 코드를 구현할 수 있다

