## Go 개발 환경
* BUILD & RUN
  * go run 명령어는 바이너리를 임시 디렉토리에 생성하고 실행 후 종료 시 삭제
  * 작은 프로그램을 테스트하거나 스크립트 언어처럼 사용할 때 유용
  * go build 는 실행 바이너리를 만든다
* 코드코매팅
  * Go의 주요 설계 목표 중 하나는 코드 작성이 효율적인 언어를 만드는 것
  * Go는 일관된 코드 포매팅을 지키지 않으면 구문 오류가 발생한다.
  * go fmt 명령어

## 기본 데이터 타입과 선언
* 선언되었지만 값이 할당되지 않은 변수에 기본값인 제로 값을 할당한다.
* 리터럴 
  * 정수 리터럴 > 123
  * 룬 리터럴 > 'H'
  * 문자 리터럴 > "Greetings"
  * 로우 문자열 리터럴 > `Greetings And "Sim"`
* Side 
  * 부동소수점 > floatNum := 10.334(이진 변환 과정에서 반올림 혹은 절삭 발생)
  * 고정소수점 > intNum := int64(floatNum * 1000),	fixedNum := float64(intNum) / 1000
* Go는 명시적 타입 변환만 지원한다.
* 변수 선언
  * var > var x int = 10 / var x = 10
  * x := 10
  * := 연산자로 할당된 변수의 사용은 함수 밖에서 불가능하다.
  * 함수 내의 로컬 변수는 :=를 사용하고 패키지 레벨에서 접근하는 변수들은 var 를 사용하자.
  * 상수는 const로 선언한다.
  * Go에서 상수는 리터럴에 이름을 부여하는 방법이다. 변수를 변경 불가능하게 선언하는 방법은 없다.
* 슬라이스
  * 배열에 대한 참조를 사용하면서 배열의 제약을 제거한 것이라 볼 수 있다. 
  * var x = []int{10, 20, 30}
  * var x []int > 정수 슬라이스를 생성해서 제로 값을 할당한다.
    * 이때 nil이 제로 값으로 할당되는데 nil은 특정 타입의 값의 부재를 표현한 식별자이다. null과는 약간 다르다.
  * 슬라이스의 슬라이싱을 통해 슬라이스에서 슬라이스를 만들게 할 수 있다.
* 맵
  * var nilMap map[string]int
    * 문자열 타입의 키와 정수를 값으로 가지는 맵이 선언된다.
    * 맵의 제로 값은 nil이다.
    * 쓰기 시도 시 패닉(Panic : Go의 런타임 에러)이 발생한다.
  * totalWins := map[string]int{}
    * 비어 있는 맵 리터럴을 사용하게 된다.
    * nil 맵과는 다르며, 길이는 0이지만 비어있는 맵 리터럴이 할당된 맵을 읽고 쓸 수 있다.
  * 키-값 쌍에 정확히 어떤 값이 들어갈지 모른다면 make를 사용해서 기본 크기를 지정하여 맵을 생성한다.
    * ages := make(map[int][]string, 10)
  * 콤마 OK 관용구
    * 맵에 키가 있는지 확인해야 하는 경우 콤마 OK 관용구를 사용한다.
    * v, ok := m["hello"]
* 구조체
  * 맵은 함수에서 다른 함수로 데이터를 넘겨주는 방식으로는 적합하지 않다.
  * 변수를 구조체 타입 이름을 지정하지 않고 익명 구조체로 쓸 수도 있다.
    * 외부 데이터를 구조체로 전환하거나 구조체를 외부 데이터로 전환(마샬링 / 언마샬링) 할 때 사용한다.
  * 구조체 vs 클래스
    * 상속
      * 클래스는 상속을 지원 (extends, implements)
      * 구조체는 상속 대신 임베딩 사용 (has-a 관계)
    * 캡슐화
      * 클래스는 private, protected, public 등 다양한 접근 제어자
      * 구조체는 대/소문자로만 구분 (대문자 public, 소문자 private)
    * 메서드 정의
      * 클래스는 내부에 메서드 정의
      * 구조체는 외부에서 receiver를 사용해 정의
    * 인터페이스 구현
      * 클래스는 명시적으로 implements 선언
      * 구조체는 암시적으로 구현 (덕 타이핑)
        * 오리처럼 걷고, 오리처럼 꽥꽥거리면, 그것은 오리다라는 개념에서 유래. 즉, 특정 인터페이스가 요구하는 메서드만 구현되어 있다면, 그 타입은 자동으로 해당 인터페이스를 구현한 것으로 간주
    * 생성자
      * 클래스는 constructor 메서드 존재
      * 구조체는 일반 함수로 생성자 패턴 구현
## 함수
* 섀도잉 변수
  * 외부 블록에서 이미 선언된 식별자와 같은 이름으로 내부 블록에서 식별자를 선언하면 섀도잉하게 된다.
    * 이건 유지보수하기 어렵게 프로그래밍 하는 수단이 아닌가?
* goto
  * 이것도 유지보수하기 어렵게 프로그래밍 하는 수단이 아닌가?
* defer
  * 함수에 얼마나 많은 종료지점이 있든 함수가 성공적으로 완료되었는지 여부에 관계 없이 실행되는 defer
  * defer 클로저 내의 코드는 Return 문이 실행된 후에 실행된다.
  * defer는 LIFO 순서로 실행된다.
* call by value
  * 함수에 파라미터로 넘겨지는 변수가 있다면 항상 해당 변수의 복사본을 만들어 넘긴다.
  * 구조체라고 하더라도 동일한 동작을 한다.
  * **맵과 슬라이스는 파라미터로 넘기더라도 넘겨진 변수에도 반영이 된다**
    * 맵과 슬라이스는 포인터로 구현되어있기 때문이다.
  * Go의 모든 타입은 값 타입이다. 때론 값이 포인터일 뿐이다.
    * 포인터를 넘기는 거면 Call By Refernce 아닌가?
## 포인터
* 값이 저장된 메모리의 위치 값을 가지고 있는 변수
* Go는 GC를 가지고 있고 포인터 산술과 C와 C++에서 포인터를 가지고 할 수 있는 기교들 일부를 비허용함으,로 메모리 관리에 대한 고통을 줄였다.
* & 연산자는 주소 연산자로, 저장된 메모리 위치의 주소를 반환한다.
* * 연산자는 간접 연산자로, 포인터 타입의 변수 앞에 붙이면 값을 반환한다. 역참조(Deferencing)라고 부른다.
  *  역참조 전에는 포인터가 nil이 아닌지 확인해야 한다. nul을 가진 포인터로 역 참조를 시도하면 프로그램은 패닉을 일으킨다.
* 포인터 타입은 포인터가 어떤 타입을 가리키는지 나타낸다. 타입 이름 앞에 * 연산자를 사용한다.
* 내장 함수 new는 포인터 변수를 생성한다. new(int)
* 포인터의 첫 번째 규칙은 포인터를 두려워하지 않는 것이다. 포인터는 클래스 인스턴스와 비슷하다.
* 포인터들은 데이터 흐름을 이해하기 어렵게 만들며 가비지 컬렉터에게 추가적인 작업을 준다. 함수 내에서 구조체를 초기화 하고 반환하는 것이 좋다.
  * 함수 간에 메가바이트 데이터를 전달한다면 이야기는 달라진다.
