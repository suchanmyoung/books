## Go 개발 환경
* BUILD & RUN
  * go run 명령어는 바이너리를 임시 디렉토리에 생성하고 실행 후 종료 시 삭제
  * 작은 프로그램을 테스트하거나 스크립트 언어처럼 사용할 때 유용
  * go build 는 실행 바이너리를 만든다
* 코드코매팅
  * Go의 주요 설계 목표 중 하나는 코드 작성이 효율적인 언어를 만드는 것
  * Go는 일관된 코드 포매팅을 지키지 않으면 구문 오류가 발생한다.
  * go fmt 명령어

## 기본 데이터 타입과 선언
* 선언되었지만 값이 할당되지 않은 변수에 기본값인 제로 값을 할당한다.
* 리터럴 
  * 정수 리터럴 > 123
  * 룬 리터럴 > 'H'
  * 문자 리터럴 > "Greetings"
  * 로우 문자열 리터럴 > `Greetings And "Sim"`
* Side 
  * 부동소수점 > floatNum := 10.334(이진 변환 과정에서 반올림 혹은 절삭 발생)
  * 고정소수점 > intNum := int64(floatNum * 1000),	fixedNum := float64(intNum) / 1000
* Go는 명시적 타입 변환만 지원한다.
* 변수 선언
  * var > var x int = 10 / var x = 10
  * x := 10
  * := 연산자로 할당된 변수의 사용은 함수 밖에서 불가능하다.
  * 함수 내의 로컬 변수는 :=를 사용하고 패키지 레벨에서 접근하는 변수들은 var 를 사용하자.
  * 상수는 const로 선언한다.
  * Go에서 상수는 리터럴에 이름을 부여하는 방법이다. 변수를 변경 불가능하게 선언하는 방법은 없다.
* 슬라이스
  * 배열에 대한 참조를 사용하면서 배열의 제약을 제거한 것이라 볼 수 있다. 
  * var x = []int{10, 20, 30}
  * var x []int > 정수 슬라이스를 생성해서 제로 값을 할당한다.
    * 이때 nil이 제로 값으로 할당되는데 nil은 특정 타입의 값의 부재를 표현한 식별자이다. null과는 약간 다르다.
  * 슬라이스의 슬라이싱을 통해 슬라이스에서 슬라이스를 만들게 할 수 있다.
* 맵
  * var nilMap map[string]int
    * 문자열 타입의 키와 정수를 값으로 가지는 맵이 선언된다.
    * 맵의 제로 값은 nil이다.
    * 쓰기 시도 시 패닉(Panic : Go의 런타임 에러)이 발생한다.
  * totalWins := map[string]int{}
    * 비어 있는 맵 리터럴을 사용하게 된다.
    * nil 맵과는 다르며, 길이는 0이지만 비어있는 맵 리터럴이 할당된 맵을 읽고 쓸 수 있다.
  * 키-값 쌍에 정확히 어떤 값이 들어갈지 모른다면 make를 사용해서 기본 크기를 지정하여 맵을 생성한다.
    * ages := make(map[int][]string, 10)
  * 콤마 OK 관용구
    * 맵에 키가 있는지 확인해야 하는 경우 콤마 OK 관용구를 사용한다.
    * v, ok := m["hello"]
* 구조체
  * 맵은 함수에서 다른 함수로 데이터를 넘겨주는 방식으로는 적합하지 않다.
  * 변수를 구조체 타입 이름을 지정하지 않고 익명 구조체로 쓸 수도 있다.
    * 외부 데이터를 구조체로 전환하거나 구조체를 외부 데이터로 전환(마샬링 / 언마샬링) 할 때 사용한다.
  * 구조체 vs 클래스
    * 상속
      * 클래스는 상속을 지원 (extends, implements)
      * 구조체는 상속 대신 임베딩 사용 (has-a 관계)
    * 캡슐화
      * 클래스는 private, protected, public 등 다양한 접근 제어자
      * 구조체는 대/소문자로만 구분 (대문자 public, 소문자 private)
    * 메서드 정의
      * 클래스는 내부에 메서드 정의
      * 구조체는 외부에서 receiver를 사용해 정의
    * 인터페이스 구현
      * 클래스는 명시적으로 implements 선언
      * 구조체는 암시적으로 구현 (덕 타이핑)
        * 오리처럼 걷고, 오리처럼 꽥꽥거리면, 그것은 오리다라는 개념에서 유래. 즉, 특정 인터페이스가 요구하는 메서드만 구현되어 있다면, 그 타입은 자동으로 해당 인터페이스를 구현한 것으로 간주
    * 생성자
      * 클래스는 constructor 메서드 존재
      * 구조체는 일반 함수로 생성자 패턴 구현