## JPA는 심플하게 써야 한다
## 객체지향적으로 복잡도를 처리해야하는 도메인이 아니라면 오히려 안 써도 된다
## 조영호님도 일단 짜고 리팩토링 한다
## 비즈니스 요구사항을 해결하는 게 아니라 JPA의 문제를 해결하고 있으면 문제가 있다
## 흔히 외부 라이브러리 혹은 프레임워크와 비즈니스 로직을 그리는 관심사를 분리하려고 하지만 JPA는 그것이 쉽지 않다
## 기술 선택은 장점과 복잡도, 팀워크 사이에서 트레이드 오프를 측정
## 복잡도를 높였을 때의 이점이 있어야 해

* 절차적인 설계 > 객체적인 설계
  * 참조 객체(엔터티, 레퍼런스 오브젝트) / 값 객체
  * 객체지향은 원래 GUI(윈도우프로그래밍, 매킨토시, 게임)에 유용했다
  * 메모리 상에 객체들이 다 있고 참조를 하고 있다고 가정하고 기ㅡㅇ을 만드는 것
    * 근데 백엔드는 DB가 들어가는 순간, 어려워진다
  * Aliasing
    * 하나의 객체르 가리키는 여러 개의 참조 변수
    * Aliasing Bug
  * 그냥 Entity / JPA Entity는 다름
  * 설계를 할 떄 대부분을 안 바뀌게 만들고(Value Object), 바꾸는 곳을 한 곳에 몰아놓고 설계
  * 설계는 내가 이 시점에 어디를 볼 거다라는 생각. 선 긋기
  * 참조 객체
    * 식별자를 기반으로 동일성 체크, 가변 객체 구현
  * 값 객체
    * 속성을 기반으로 객체 동등성 체크
    * 불변 객체로 구현
    * Composition
      * lifeCycle이 종속
      * 기간 같은 경우도 Start ~ End를 값 객체로 기간으로 해버리면 어떡함?
    * @Embeddable
    * @AttributeOveeride
    * @AttributeConverter
    * 개념적으로 묶이는 애들
    * 같이 밸리데이션 한다던가, 같이 값을 바꾼다던가 하는 
    * 가급적으면 밸류 오보젝트를 쭉 만들고ㅡ
    * QUERY DSL과, JPAQL을 쓴다면, 적정 수준 까지만 값 개게를 쓸 것
    * 같은 로직을 재활용?
      * 중복코드.. A를 바꿀 때 B를 바꿔야한다
      * 하지만 소유권이 달라 > 완전 같아보여
      * 하지만 소유권, 관리 때문에 찢거나 하자
      * 코드의 소유권에 따라 중복코드나 아니냐 정하는 게 중요하다
  * 코드는 버그 없이 만들기 + 다른 사람이 읽을 수 있게
    * 일단 동작하게 만들고
      * 리팩토링 한다
    * 다 primitive타입이면 읽는 사람들이 해석해야 함
    * 값 객체를 써서 해결할 수 있음
* 영속성 컨텍스트
  * 작업 단위
  * 식별자 맵
    * 원본과 스냅샷 
      * 변경 감지를 위해
      * flush 시점에 서로를 비교하면서 UPDATE 쿼리가 나간다
  * 식별자맵 > 작업 단위 > 쓰기 지연 SQL 저장소
  * 상태 전이
    * 비영속(Transient)
      * 그냥 객체만 만든 시점을 비영속이라 함
      * 객체를 만들고 > persist() 하면 영속화됨
    * 영속(Persistenet)
      * find()
      * 식별자 맵에 들어가 있는 상태
    * 제거(Remove)
      * DELETE 쿼리를 쓰기 지연 SQL 저장소에 등록해놓은 상태
      * 영속성 쿼리에서 날아감
    * 준영속(Detach)
      * 영속성 컨텍스트에 있다가 다시 나옴(clear)
      * merge, DB에서 다시 데이터를 가지고 와서 합치는데... 이런 거 쓰지 마라
  * 쓰기 지연 SQL 저장소
    * flush() 트랜잭션이 커밋될 때 자동으로 플러시
    * Id, ID xkdlqdl IDENTITY면 ID를 채번해야되기 때문에 디비 INSERT 해버린다
    * 커밋은 안한다
    * ORACLE INSERT LOGMINE
    * flush를 직접 쓴다...? 뭔가 이슈가 있는 상황임
    * flush를 해도 영속성 컨텍스트에는 남아 있다
    * 트랜잭션 경계
  * 보장된 객체 식별자 범위
    * 1차 캐시 역할
  * 도달가능성에 의한 영속성
  * 캡슐화 관점에서 아주 중요함
  * 객체는 항상 묶어서 돌아다닌다
  * 즉시 로딩 VS 지연 로딩
    * 즉시 로딩
      * 이걸 줘, 하는 순간 같이 딸려서 온다
    * 지연 로딩
      * 내가 PK만 알고 있는 상태다(접근할 때 읽어야 하니)
      * 프록시가 설정된 상태에서 트랜잭션을 끝낸 다음 프록시에 접근하면 에러가 난다
      * 트랜잭션의 경계 사이에서 끝내는 게 좋아
  * readOnly를 true로 하면 영속성 컨텍스트에 저장하지 않는다
  * JPQL(Jakarta Persistence Query Language)
    * 객체를 기준으로 쿼리를 짜는 거
    * 트랜잭션을 커밋하지 않았는데 flush가 날아갈 때가 있음
    * JPQL을 쓰면 우선 flush 한다(commit은 아님)
  * 책임 주도 설계
    * 유스케이스는 시스템의 동작을 쓰는 것(입력 > 결과), 짧게 줄이면 스토리
    * 객체지향은 컨텍스트를 정의하고 필요한 객체들부터 설계함
    * 시스템의 책임을 객체의 책임으로 변환
    * 책임을 담당할 적절한 객체 선택
  * TDD를 하려면
    * 어떤 객체에서 시작될 지를 알아야 함
    * 설계를 잘해야 함
* 영화 예매 시스템 설게
  * 클래스 다이어그램을 주고 이거 잘된거에요? 라는 질문에는 답을 할 수가 없다
  * 좋은 설계는 쉽게 변경할 수 있는 거
  * 변경에 쉽게 따라가려면 코드를 빨리 찾아야 한다
  * 객체지향은 데이터와 행위를 묶는 거
  * 응집도 관점
  * 책임 할당의 기본 원칙
    * 도메인 개념 중에 적절한 전문가에게 할당
    * 예매 할 건데 어느 객체로 시작해야할까?
    * 글쓰기와 비슷하다
  * 트랜잭션 스크립트 방식
  * 객체지향 설계는 결국 변경이 예상되는 지점이 어딘지 찾는 거
  * IF ELSE도 괜찮아
  * 객체지향은 읽기 어려워...
  * 일단 이해를 하면 구조가 머리에 남는다
  * 객체지향을 잘 하려면.... 정보 전문가(Domain Model) 분리를 잘 해야 해
    * 이게 잘못되면 오히려 더 읽기 어려움
  * 시스템의 코어고.. 변경이 너무 많으면...
    * 찢어야 한다...
  * 연관관계
    * 단방향이냐...
    * 양방향이냐...
    * 객체지향 설계 관점에서는 무조건 단방향으로 만들 수 있는데...
    * 단방향으로 잡는 거는 아주 좋을 거 같은데?
    * 양방향은 복잡도가 너무 올라간다
    * 연관관계 주인 > FK를 관리할 책임을 할당 > FK를 가지고 있는 테이블 
    * 주인의 참조를 정확하게 설정하지 않은 경우(mapped by)
      * move에 screnning만 추가하더라도 실제 변경되지 않음
    * DB와 객체의 모델링 패러다임이 다른 것을 인지해야한다
    * **우리 프로젝트에 연관관계를 설젛아는 것이 정말 맞는지? 연관관계를 설정하는 순간 엄청난 복잡도가 수반된다.**
    * **JPA는 ORM이기 때문에 일단 객체지향을 베이스로 깔아버려**
  * 영속성 전이
    * GenerationType.IDENTITY가 아니더라도? INSERT - UPDATE가 나가나?
      * 논리적으로는 INSERT가 한방에 나가는 게 맞지만, JPA는 이것까지는 모른다 
    * 캡슐화의 경계를 끊을 때는 ID를 이용한 간접참조
  * FetchType
    * 영속성 전이는 설정한 단위로 "저장"하고 싶어
    * FetchType은 설정한 단위로 "읽고" 싶어
    * FetchTYpe.LAZY
      * Proxy 객체에 대해 DB에 가지 않더라도 ID를 알고 있어야 해
      * 원본이 FK를 들고 있어야 한다
      * Movie가 FK를 알 수 없기 떄문에 값의 존재 유무 판단 불가능  
      * 런타임에 프록시를 생성할 수 있는지에 따라 지연 로딩 가능 여부 결정
    * PersistenceBag 
      * Bag Collection > 중복 허용, 순서 미유지 : 빠름
      * Set Collection > 중복 미허용, 순서미유지 
      * List Collection(with @OrderColumn) > 중복 허용, 순서 유지 > 쓰지 마라
      * 컬렉션 요소 삭제 = 레코드는 그대로 두고 FK만 null로 세팅
        * orphanRemoval = True 하면 FK가 Null인 고아 객체를 삭제
        * 라이프사이클이 얼마나 연결되어있는지의 강도에 따라 설정
      * 값 객체 컬렉션
        * @ElementCollection @CollectionTable
        * 값 객체는 원래 테이블이 없음 > 근데 값이 N개면 DB는 무조건 테이블이 있어야 함
        * 값 객체가 컬렉션이 되는 구조면... 애초에 테이블 설계 레벨에서 1:N으로 풀려있을 거 같은데 많이 쓰나...?
        * 값으로 읽어버려서 차이가 좀 있다
      * 참조 객체 컬렉션 삭제
        * 요소 개수만큼 delete 됨
      * 값 객체
        * 첨부파일 스트링을 이미지를 밀어 넣을 때
        * N개를 넣은 다음에 > string으로 먼가를 하고 싶음
        * 첨부파일을 경로에 업로드 하고 기존꺼를 날리고
        * 다시 업로드 한다
        * 이미지를 다시 올리고
        * 이미지를 해시 같은 걸 다시 따고 
        * 이미지 경로를 다시 조정하는 경우 > 밸류 오브젝트로 한다
        * 이미지 업로드를 하지만, 선택적으로 업로드 하는 경우에는 > 엔터티로 매핑해버린다
        * 모든 걸 재구성할거냐... 
          * JPA 엔터티는 레퍼런스 오븝젝트가 아니다
          * 엔터티는 디비에 저장하기 위한 용도
          * 시멘틱은 immutable, value 오브젝트
          * 하지만 DB의 어떤 관계 때문에, entity로 매핑해
          * JPA Entity <> Reference 두 개의 개념 차이가 있다
          * value object <> 객체로 쓰는 거는 아예 다르다
          * 아예 재구성하는 경우 Value Object Collection <> 한 건, 한 건 한다 > 레퍼런스 객체
  * 상속 매핑
    * 객체지향의 상속은 다형성 때문에 사용
    * 다형적인 연관관계
    * 행동 관점으로 엔티티를 설계해놓고 <> DB를 어떤 형태로 맞출 것인가? > 상속 매핑의 전략
    * 단일 테이블 전략 + 조인 테이블 전략 조합
      * Entity 기준으로 늘려야하지만, 한 테이블이 너무 커져있는 상태에서 사용
    * 결과적으로는 조인 전략이 가장 좋지만, 초반부터 설계를 할 수 없다 > 레거시 리팩토링을 한다에서는 적절하게 선택할 수 있다
    * 상속 계층은 가급적 간단하게 유지
      * 클래스 레벨에서의 상속 계층 설계가 매핑 전략보다 더 중요하다프레임워크는 다르다 > 재사용성이 가장 중요해서
      * 근데 비즈니스 레이어를 할 때는 다르다상속 계층이 깊으면 부모-자식 간에 계속 왔다갔다 하면서 메소드를 콜하기 때문에 읽기가 쉽지 않다
    * 상속은 코드 재사용을 위해 쓰는가?
      * 상속은 부모 클래스에서 다른 점을 계속 증분 시키는 것
      * 다중 상속 불가
      * 취약한 기반 클래스(자식을 신경 안 쓰고 부모 클래스를 막 바꿀 수 있다) > 부모 클래스의 수정으로 인해 자식 클래스 버그 발생
      * 상속보다 합성을 사용 하라
      * Movie > PercentDisocuntMove 가 아니라, Movice + DiscountPolicy
      * 부모 클래스의 잘못된 클래스를 오버라이딩 하면 동작이 이상해질 수 있다
      * 상속 관계에서 특정 메서드를 구현하는 구체 클래스는 단 하나! > Interface
      * 데이터 상속을 해야 한다면, @MappedSupperClass를 써라
  * 애그리게이트와 연관 관계
    * 객체지향에서는 캡슐화, 계층화, 어떻게 묶어서 가져갈 것인가
    * 회사마다, 상황마다 캡슐화 경계를 정하는 기준이 다르다
    * JPA를 사용하면서 발생하는 많은 문제의 원인
      * 객체 그룹 사이에 경계가 없이 모든 객체가 동일한 수준에서 연결
    * 객체 그룹 경계로 JPA 적용
      * 객체를 그룹으로 묶어 캡슐화시킨 후 그룹 단위로 설정 적용
      * DDD > 불변식(트랜잭션 일관성.. Invariant)을 기준으로 그룹화
      * 경계(Boundary)
    * 여긴 내맘대로 바꾸면 안돼 / 여긴 내맘대로 바꿔도 돼
      * 사이드 이펙트가 끝나는 지점을 만들어야 함
      * 이게 캡슐화
      * 좋은 코드가 뭔지를 알고.. 지저분한 뭔가 있었을 때 고칠 수 있어야 하는데... 근데 일정 앞에는 장사 없다. 내일 나가야 돼...
      * 에그리게이트는 저장의 단위
        * 애그리게이트 당 Repository는 하나
        * 에그리게이트 사이에서는 연관관계를 단방향으로 관리하거나 한다
        * 아예 간접참조로 id 필드로 참조하거나
      * 주문할 때의 상품이랑.... 
      * 조회할때의 상품이랑.... 다른 애가?
  * 컬렉션 로딩의 두 가지 문제
    * 즉시 로딩
      * 데카르트 곱 문제제 : 두 개의 컬렉션을 포함한 상태에서 
    * 지연 로딩
      * N + 1 > Hibernate의 batch fetch, 혹은 서브쿼리
    * Entity에 선언하는 Annotation들은 JPQL을 쓸 때 무조건 전역 설정
      * 이거를 무시할 수 있는
        * JPQL 페치 조인* inner join이라 데이터 잘 봐야함
          * 여기 내부 엔티티에 EAGER 있으면 eager는 전역
        * 엔티티 그래프
          * @NamedEntityGraphs : 연관관계를 끌어오는 정도를 지정
  * 동시성 제어
    * 이슈
      * Lost UPDATE
      * Dirty Read
      * UnREPEATABLE READ
      * Phantom Read
    * 불변과 격리로 다루자(isolation) > 이걸 트랜잭션으로 한다
    * 격리 수준
      * READ_UNCOMMITED
      * READ_COMMITED > JPA 기본 가이드
      * REREPEATABLE_READ > JPA는 영속성 컨텍스트가 제공해줌
      * SERIALIZABLE
    * 동시성 문제는 항상 퍼포먼스 VS 일관성의 트레이드오프
    * 낙관적 잠금
      * 이슈가 크지 않을 거야. 충돌 가능성이 낮은 경우 > 업데이트 할 때 하자
      * @Version : 잘 안쓴다, exclude로 특정 필드 업데이트는 안 쓸 수 있음
      * @UpdateTimestamp : DB 시간으로
      * 동시성 이슈는 많이 무시하는 경우도 많다... 대부분 유저 한 명이 접근하니까...
        * 자주 발생하지 않는데... 이제는 별로 좋아하지 않는다
        * 트래픽이 적을 때는 거의 발생하지 않는다
        * 데이터베이스는 하난데, 시스템이 늘어나
        * 요즘은 그냥 디비 여러 개로 나누고 싱크 맞춰버린다
        * 상품 재고에 원래 썼다가
        * 10개면 > 10개 팔려야된다...
        * 관리자가 10개 세팅했으면 10개만 팔려야한다 > 개발자 마인드
        * 어차피 내일 배송인데 일단 - 찍고 내일 제품 구하면 되잖아
        * 동시성 이슈를 그냥 무시하자.. 개발자 리소스가 너무 드니까... 차라리 그냥 보정배치를 하는 게 나음 
      * 객체 여러 개를 낙관적 잠금을 거는 거
    * 비관적 잠금
      * 조회 시점에 아예 LOCK
  * 질답 타임
    * 결제 도메인?
      * 우리는 이 사용자가 결제를 했어 > 콜백을 때린다 > 우리 쪽 트랜잭션 > 콜백을 받아
      * 콜백 PG 
      * 콜백으로 대사 처리
      * 대사, 주문, 결제, PG사 정산
      * UI 쪽에서 펜딩하고 있다가... > 서버가 콜백을 받으면 > 응답
      * 이게 아니면 > 결제가 밀림
      * 보정으로 처리해줘야한다
      * 주문이나 결제는 절대 밀리면 안됨
      * 주문 > 결제 비동기 넘기고
      * 사용자한테는 UI 쪽에서 일단 계속 찌르다가 결제쪽에 처리가 되면 상태를 처리한다   
    * 주문할 때의 주문 트랜잭션과
      * 결제 쪽에서 뭐가 오면 트랜잭션이 다르다
      * 길어지면 다른 시스템에 연동하는 거 때문에 길어진다
      * 외부 시스템이 또 밀릴 수가 있다
      * 동기적으로 절대 처리하면 안됨
      * 아예 STATUS를 트랜잭션 마다 끊어서
      * 비동기적으로 처리한다
      * 1번 됐어요 > 2번 됐어요 > 3번 됐어요
      * 이래서 가장 중요한 게 "대사"라는 과정이 필요함
      * 대사를 해서 이거를 커버해야 함
      * 주문이 안 됐는데, 결제가 됐다
      * 이거를 빨리빨리 대사 쳐서 처리하는 과정이 꼭 필요 함
    * 어그리게이트는 루트만 있으면 되나?
      * 주문이 업데이트 됐는데 사용자가 업데이트 돼?
      * "도메인 단위" 라는 게 중요함
      * Service 레이어도 어그리게이트인가 ? > 이건 기능 단위의 묶인 거 뿐
      * 주문이 업데이트 되면 > 사용자가 업데이트 되고 > 빌이 업데이트 된다
      * 이건 어그리게이트가 아님
      * 딱 하나의 도메인, 어그리게이트 관리하는 레이어가 있음  
    * 비즈니스로직을 처리하는 테이블 엔티티를 써
    * 조회용으로 하는 엔티티는 나눠라
    * DTO
      * 버티컬 단위로 그냥 다 나누는 게 나아
      * 수정/생성을 같은 DTO로
      * 같이 쓸 수 있는 DTO는 재사용할 수 있도록 해라
      * Controller는 Service까지는 절차적이다 
    * 코드가 틀어진다는 가정 하에 짜면 아주 직관적이지않아진다.... 
    * 차라리 그냥 직관적으로 짜고 CX 치자
    * 발생할지 안할지도 몰라
    * 그냥 주기적으로 감지하는 배치를 만들어
    * 내 리소스는 현실적으로 메이저 이슈 치느라 바쁘다
  * 탐색
    * 객체 참조를 통한 탐색(강한 결합)
    * 제 3의 객체를 통해 탐색(즉 id를 필드로 가지고 repository로 연관관계 해결)
  * Spring Data JDBC
    * 상속 JPQL 없음
    * 클래스명이랑 컬럼명을 가지고 클래스를 만들어줘
    * 무조건 같아야 돼
    * 무조건 Valud Object로 만들어버림
    * 읽을 때 무조건 에그리게이트 써버려
  * 단순 데이터 조회는?
    * 에그리게이트는 수정과 생성을 위한 거임
    * 근데 비즈니스 로직을 처리하는 게 단순 데이터 조회에 변경이 있다? 이건 뭔가 이상한 거임
    * 데이터를 처리해야하니까 그냥 반대 참조 막 걸어보고 싶은 거임
    * 엔티티를 만들어버렸기 떄문에 재사용하고 싶다
    * 데이터 조회(데이터로직을 다루고 있어!, 비즈니스 로직 다루는 거 아니야!)
      * 이건 트랜잭션 스크립트 패턴을 ㅗ구현
    * 아예 UI에 맞는 쿼리를 하나 짜버리는 게 나을 수도 있다
      * 이 레포지토리를 하나 만들어서
      * 그냥 거기선 쿼리 막 조지는거임 네이티브 쿼리로
      * 바로 DTO 리턴해버려
      * 데이터 처리랑 vs 비즈니스 로직 다루는 거 섞어버려
      * UI 바뀜 VS 
      * 에그리게이트의 경계는 그냥 수정단위임...!!!
      * 조회는 타팀과의 책임 분리도 없으니까
      * 데이터는 플랫 해
      * 계층관계가 없어
  * 일정 VS 퀄리티
    * 객체지향 : 딱 리팩토링할 수 있는 지점까지 간다
    * DDD : 방법론이 아니다... 이건 마인드다, 비즈니스 관점에서 생각해라.. 사람들이랑 공유해..
    * DDD의 결과물 <> 객체지향 설계
    * DDD는 그냥 비즈니스 마인드 퍼스트, 풀어야하는 문제를 잘 알아야 돼, 문제를 잘 아는 사람의 의견을 들어야 돼