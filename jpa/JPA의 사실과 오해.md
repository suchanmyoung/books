## JPA는 심플하게 써야 한다
## 객체지향적으로 복잡도를 처리해야하는 도메인이 아니라면 오히려 안 써도 된다
## 조영호님도 일단 짜고 리팩토링 한다

* 절차적인 설계 > 객체적인 설계
  * 참조 객체(엔터티, 레퍼런스 오브젝트) / 값 객체
  * 객체지향은 원래 GUI(윈도우프로그래밍, 매킨토시, 게임)에 유용했다
  * 메모리 상에 객체들이 다 있고 참조를 하고 있다고 가정하고 기ㅡㅇ을 만드는 것
    * 근데 백엔드는 DB가 들어가는 순간, 어려워진다
  * Aliasing
    * 하나의 객체르 가리키는 여러 개의 참조 변수
    * Aliasing Bug
  * 그냥 Entity / JPA Entity는 다름
  * 설계를 할 떄 대부분을 안 바뀌게 만들고(Value Object), 바꾸는 곳을 한 곳에 몰아놓고 설계
  * 설계는 내가 이 시점에 어디를 볼 거다라는 생각. 선 긋기
  * 참조 객체
    * 식별자를 기반으로 동일성 체크, 가변 객체 구현
  * 값 객체
    * 속성을 기반으로 객체 동등성 체크
    * 불변 객체로 구현
    * Composition
      * lifeCycle이 종속
      * 기간 같은 경우도 Start ~ End를 값 객체로 기간으로 해버리면 어떡함?
    * @Embeddable
    * @AttributeOveeride
    * @AttributeConverter
    * 개념적으로 묶이는 애들
    * 같이 밸리데이션 한다던가, 같이 값을 바꾼다던가 하는 
    * 가급적으면 밸류 오보젝트를 쭉 만들고ㅡ
    * QUERY DSL과, JPAQL을 쓴다면, 적정 수준 까지만 값 개게를 쓸 것
    * 같은 로직을 재활용?
      * 중복코드.. A를 바꿀 때 B를 바꿔야한다
      * 하지만 소유권이 달라 > 완전 같아보여
      * 하지만 소유권, 관리 때문에 찢거나 하자
      * 코드의 소유권에 따라 중복코드나 아니냐 정하는 게 중요하다
  * 코드는 버그 없이 만들기 + 다른 사람이 읽을 수 있게
    * 일단 동작하게 만들고
      * 리팩토링 한다
    * 다 primitive타입이면 읽는 사람들이 해석해야 함
    * 값 객체를 써서 해결할 수 있음
* 영속성 컨텍스트
  * 작업 단위
  * 식별자 맵
    * 원본과 스냅샷 
      * 변경 감지를 위해
      * flush 시점에 서로를 비교하면서 UPDATE 쿼리가 나간다
  * 식별자맵 > 작업 단위 > 쓰기 지연 SQL 저장소
  * 상태 전이
    * 비영속(Transient)
      * 그냥 객체만 만든 시점을 비영속이라 함
      * 객체를 만들고 > persist() 하면 영속화됨
    * 영속(Persistenet)
      * find()
      * 식별자 맵에 들어가 있는 상태
    * 제거(Remove)
      * DELETE 쿼리를 쓰기 지연 SQL 저장소에 등록해놓은 상태
      * 영속성 쿼리에서 날아감
    * 준영속(Detach)
      * 영속성 컨텍스트에 있다가 다시 나옴(clear)
      * merge, DB에서 다시 데이터를 가지고 와서 합치는데... 이런 거 쓰지 마라
  * 쓰기 지연 SQL 저장소
    * flush() 트랜잭션이 커밋될 때 자동으로 플러시
    * Id, ID xkdlqdl IDENTITY면 ID를 채번해야되기 때문에 디비 INSERT 해버린다
    * 커밋은 안한다
    * ORACLE INSERT LOGMINE
    * flush를 직접 쓴다...? 뭔가 이슈가 있는 상황임
    * flush를 해도 영속성 컨텍스트에는 남아 있다
    * 트랜잭션 경계
  * 보장된 객체 식별자 범위
    * 1차 캐시 역할
  * 도달가능성에 의한 영속성
  * 캡슐화 관점에서 아주 중요함
  * 객체는 항상 묶어서 돌아다닌다
  * 즉시 로딩 VS 지연 로딩
    * 즉시 로딩
      * 이걸 줘, 하는 순간 같이 딸려서 온다
    * 지연 로딩
      * 내가 PK만 알고 있는 상태다(접근할 때 읽어야 하니)
      * 프록시가 설정된 상태에서 트랜잭션을 끝낸 다음 프록시에 접근하면 에러가 난다
      * 트랜잭션의 경계 사이에서 끝내는 게 좋아
  * readOnly를 true로 하면 영속성 컨텍스트에 저장하지 않는다
  * JPQL(Jakarta Persistence Query Language)
    * 객체를 기준으로 쿼리를 짜는 거
    * 트랜잭션을 커밋하지 않았는데 flush가 날아갈 때가 있음
    * JPQL을 쓰면 우선 flush 한다(commit은 아님)
  * 책임 주도 설계
    * 유스케이스는 시스템의 동작을 쓰는 것(입력 > 결과), 짧게 줄이면 스토리
    * 객체지향은 컨텍스트를 정의하고 필요한 객체들부터 설계함
    * 시스템의 책임을 객체의 책임으로 변환
    * 책임을 담당할 적절한 객체 선택
  * TDD를 하려면
    * 어떤 객체에서 시작될 지를 알아야 함
    * 설계를 잘해야 함
* 영화 예매 시스템 설게
  * 클래스 다이어그램을 주고 이거 잘된거에요? 라는 질문에는 답을 할 수가 없다
  * 좋은 설계는 쉽게 변경할 수 있는 거
  * 변경에 쉽게 따라가려면 코드를 빨리 찾아야 한다
  * 객체지향은 데이터와 행위를 묶는 거
  * 응집도 관점
  * 책임 할당의 기본 원칙
    * 도메인 개념 중에 적절한 전문가에게 할당
    * 예매 할 건데 어느 객체로 시작해야할까?
    * 글쓰기와 비슷하다
  * 트랜잭션 스크립트 방식
  * 객체지향 설계는 결국 변경이 예상되는 지점이 어딘지 찾는 거
  * IF ELSE도 괜찮아
  * 객체지향은 읽기 어려워...
  * 일단 이해를 하면 구조가 머리에 남는다
  * 객체지향을 잘 하려면.... 정보 전문가(Domain Model) 분리를 잘 해야 해
    * 이게 잘못되면 오히려 더 읽기 어려움
  * 시스템의 코어고.. 변경이 너무 많으면...
    * 찢어야 한다...
  * 연관관계
    * 단방향이냐...
    * 양방향이냐...
    * 객체지향 설계 관점에서는 무조건 단방향으로 만들 수 있는데...
    * 단방향으로 잡는 거는 아주 좋을 거 같은데?
    * 양방향은 복잡도가 너무 올라간다
    * 연관관계 주인 > FK를 관리할 책임을 할당 > FK를 가지고 있는 테이블 
    * 주인의 참조를 정확하게 설정하지 않은 경우(mapped by)
      * move에 screnning만 추가하더라도 실제 변경되지 않음
    * DB와 객체의 모델링 패러다임이 다른 것을 인지해야한다
    * **우리 프로젝트에 연관관계를 설젛아는 것이 정말 맞는지? 연관관계를 설정하는 순간 엄청난 복잡도가 수반된다.**
    * **JPA는 ORM이기 때문에 일단 객체지향을 베이스로 깔아버려**